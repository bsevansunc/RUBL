################################################################################
# Niche equivalency and predicted niche occupancy 
################################################################################
# Author: Brian S Evans
# Updated: 5/6/2014
#
# This script is used to evaluate the question: Do small/large flocks occupy the
# same environmental niche (habitat) as birds not associated with flocks? The
# script runs the niche equivalency test as described by Warren et al. 2008
# (see ?niche.equivalency.test in the package phyloclim for citation) and the
# predicted niche occupancy about a given environmental variable as described 
# by Evans et al. 2009 (see ?pno in the package phyloclim for citation)
#-------------------------------------------------------------------------------
# Set-up
#===============================================================================

source('C:/Users/Brian/Documents/GitHub/RUBL/maxent_prep.R')

# Gather eBird background points (same regardless of species group):
# Note: "-19" removes the k-fold column, which will not be used here.

ebird = swd.list$swd.lf.all[swd.list$swd.lf.all$sp == 0,-19]

#-------------------------------------------------------------------------------
# Random sample of points across flock size classes
#===============================================================================
# Generate a random sample of species 1 by species 2
# Note: Species 1 is the species of interest, comparison to species 2

random.swd.pair = function(sp1, sp2){
  # Get species data:
  s1 = swd.list[[sp1]]
  s1 = s1[s1$sp == 1,]
  s2 = swd.list[[sp2]]
  s2 = s2[s2$sp == 1,]
  # Combine into one file:
  pres = rbind(s1,s2)
  # Determine the sample size as the proportion of species 1:
  prob.s1 = length(s1[,1])/length(pres[,1])
  # Generate random value of 1 or 0 with the probability of obtaining
  # a 1 related to the # of s1 observations:
  pres$s.rand = rbinom(length(pres[,1]),1,prob.s1)
  # Select species randomly assigned as "1" and remove "s.rand" and k
  pres = pres[pres$s.rand == 1,]
  pres[,-c(19,20)]
}

#-------------------------------------------------------------------------------
# Function to run maxent models for niche equivalency analysis:
#===============================================================================

mod.run = function(sp){
  # Get presence data (the if statement determines whether you pull the real 
  # data or a permutation of the data):
  if (length(sp) == 1) 
    pres = swd.list[[sp]][,-c(19,20)]
  else
    pres = random.swd.pair(sp[1],sp[2])
  # Combine with background ("ebird") data:
  max.in = rbind(pres,ebird)
  env = max.in[,-c(1:3)]
  pa = max.in[,1]
  # Set model arguments
  mod.args = c('nothreshold', 'nohinge', 'noproduct','noquadratic',
               'addallsamplestobackground',
               'writebackgroundpredictions','writeplotdata',
               'noautofeature','nooutputgrids',
               'maximumiterations=10000', 'verbose')
  # Run maxent model with training and background data:
  mod = maxent(env, pa, args = mod.args)
  # Create a model evaluation object:
  eval = evaluate(pres[,-c(1:3)], a = ebird[,-c(1:3)],model = mod)
  # Predict model values:
  max.in$predictions = predict(mod, env, args = c('outputformat=raw'))
  max.in
  # Create output map:
  map.out = predict(mod, env.stack, args = c('outputformat=raw'))
  return(map.out)
}

#-------------------------------------------------------------------------------
# Niche equivalency analysis
#===============================================================================
# The goal of this analysis is to determine the modified-Hellinger distances
# between flock size classes, then the m-H distances of a null distribution
# generated by randomly permuting values of "species x" and "species y". M-H
# distances vary from 0, in which there is no overlap between niches, to 
# 1, in which two niche models are identical.

#-------------------------------------------------------------------------------
# Function to calculate modified Hellinger distances for a given model run
#-------------------------------------------------------------------------------
# This can be used to calculate modified Hellinger distances of empirical or
# null distributions (based on randomization).

I.dist = function(run.x, run.y){
  # Load raw probabilities:
  p.x = run.x
  p.y = run.y
  # Calculate the Hellinger distance (Warren 2008, pg. 2870, EQ 2)
  h1 = (sqrt(p.x)-sqrt(p.y))^2
  h2 = cellStats(h1,'sum')
  h = sqrt(h2)
  # Calculate the modified Hellinger distance (pg. 2870, EQ 3)
  I = 1 -.5*h
  return(I)
}

null.I = function(species1, species2){
  mod1 = mod.run(c(species1, species2))
  mod2 = mod.run(c(species2, species1))
  I.dist(mod1, mod2)
}

#-------------------------------------------------------------------------------
# Function to run niche equivalency analyses on two flock size classes
#-------------------------------------------------------------------------------
# This function generates a list of two elements, slot1 contains the modified-H
# distance (I) of the empirical data and slot2 contains the modified-H of the
# null distribution.

run.nea = function(sp1, sp2){
  I.empirical = I.dist(mod.run(sp1), mod.run(sp2))
  I.null = numeric()
  for (i in 1:100){
    I.null[i] = null.I(sp1,sp2)
  }
  nea.list = list(I.empirical, I.null)
  names(nea.list) = c('I.empirical','I.null')
}

#-------------------------------------------------------------------------------
# Run niche equivalency analyses
#-------------------------------------------------------------------------------

# Large flock vs. small flock:

I.lf.sf = run.nea('swd.lf.all','swd.sf.all')

# Large flock vs. individual sightings (<20 individuals):

I.lf.ind = run.nea('swd.lf.all','swd.ind.all')

# Small flock vs. individual sightings (<20 individuals):

I.sf.ind = run.nea('swd.sf.all','swd.ind.all')

#-------------------------------------------------------------------------------
# Stats for niche equivalency analyses
#-------------------------------------------------------------------------------
# Statistic pairwise comparisons of null and actual modified-Hellinger distances
# for large vs. small flocks, large vs. individual sightings and small flocks 
# vs.individual sightings. Outputs include:
#   1) Modified-Hellinger distance for the actual data
#   2) Mean and standard error of the null modified_Hellinger distances
#   3) The 5 and 10% mH distances associated with null distributions.
#   4) One-tailed test of the null hypothesis that the actual mH distance is 
#      not lower than the null distance.

###############################
# LARGE FLOCK VS. SMALL FLOCK:
###############################

# Test ins:

null.dist.lf.sf = I.lf.sf[[2]]
emp.dist.lf.sf = I.lf.sf[[1]]

# Summary stats:

emp.dist.lf.sf
mean(null.dist.lf.sf)
se(null.dist.lf.sf)

# Determine the percentile associated with the empirical modified-H:

quantile(null.dist.lf.sf, probs = 0.05)
quantile(null.dist.lf.sf, probs = 0.1)
ecdf(null.dist.lf.sf)(emp.dist.lf.sf)

###############################
# LARGE FLOCK VS. INDIVIDUALS:
###############################

# Test ins:

null.dist.lf.ind = I.lf.ind[[2]]
emp.dist.lf.ind = I.lf.ind[[1]]

# Summary stats:

emp.dist.lf.ind
mean(null.dist.lf.ind)
se(null.dist.lf.ind)

# Determine the percentile associated with the empirical modified-H:

quantile(null.dist.lf.ind, probs = 0.05)
quantile(null.dist.lf.ind, probs = 0.1)
ecdf(null.dist.lf.ind)(emp.dist.lf.ind)

###############################
# SMALL FLOCK VS. INDIVIDUAL:
###############################

# Test ins:
null.dist.sf.ind = I.sf.ind[[2]]
emp.dist.sf.ind = I.sf.ind[[1]]

# Summary stats:

emp.dist.sf.ind
mean(null.dist.sf.ind)
se(null.dist.sf.ind)

# Determine the percentile associated with the empirical modified-H:

quantile(null.dist.sf.ind, probs = 0.05)
quantile(null.dist.sf.ind, probs = 0.1)
ecdf(null.dist.sf.ind)(emp.dist.sf.ind)

#-------------------------------------------------------------------------------
# Plot the histograms
#-------------------------------------------------------------------------------
# Histograms compare the density distribution of the modified-Hellinger 
# distances of the null models against the distance of the actual model for
# large vs. small flocks, large vs. individual sightings and small flocks vs. 
# individual sightings.

# Histogram function:

hist.mhd = function(null.dist, emp.dist,main.label,out.name, leg){
  plot.new()
  setwd('C:/Users/Brian/Documents/rubl_out')
  jpeg(out.name, 1200,1200, res = 300)
  hist(null.dist, breaks = seq(0,1, by = .05), freq = F,
       xlim = c(0,1), ylim = c(0,10),
       col = 'gray80', cex.lab = .9,
       main = main.label,
       xlab = 'Modified-Hellinger distance (I)')
  lines(c(emp.dist, emp.dist), c(0,10), lwd = 2, lty = 2)
  if (leg == T)
    legend(.02,10,'Null distance','gray80',1, bty = 'n',
           x.intersp = .95, cex = .7)
  if (leg == T)
    legend(0,9,'Actual distance',lty = 2,bty = 'n', 
           x.intersp = .4, cex = .7)
  dev.off()
}

# Make plots:

hist.mhd(null.dist.lf.sf, emp.dist.lf.sf, 
         'Large vs.small flock sightings', 'mh_dist_lf_sf.jpg',T)
hist.mhd(null.dist.lf.ind, emp.dist.lf.ind, 
         'Large flock vs. individual sightings', 'mh_dist_lf_ind.jpg',F)
hist.mhd(null.dist.sf.ind, emp.dist.sf.ind, 
         'Small flock vs. individual sightings', 'mh_dist_sf_ind.jpg',F)

#-------------------------------------------------------------------------------
# Predicted niche occupancy
#===============================================================================

#-------------------------------------------------------------------------------
# PNO functions:
#-------------------------------------------------------------------------------

# Calculate pno:

pno = function(mod.x, mod.y, env.var){
  # Sum the raw probabilities about a given value of an environmental variable:
    pno.df = data.frame(zonal(mod.x,env.stack[[env.var]],'sum', digits = 2))
    pno.df[,3] = zonal(mod.y,env.stack[[env.var]],'sum', digits = 2)[,2]
      colnames(pno.df) = c('env','pno.sp1','pno.sp2')
    pno.df
  }

# Determine the modified-Hellinger distance between two pnos:

pno.I = function(mod.x, mod.y, env.var){
  pno.df = pno(mod.x, mod.y, env.var)
  # Calculate the modified-Hellinger distance (I):
  niche.overlap(pno.df)[2,1]
  }

# Determine the modified-Hellinger distance between null pnos:
# Note: As above, permutation of sp1 and sp2 

pno.null = function(species1, species2, env.var){
  mod1 = mod.run(c(species1, species2))
  mod2 = mod.run(c(species2, species1))
  pno.I(mod1, mod2, env.var)
}

# Run pno models, returns a list of the
# actual pno-I (one value) and a vector of 100 null pno-I's:

run.pno = function(sp1, sp2, env.var){
  pno.empirical = pno.I(mod.run(sp1), mod.run(sp2), env.var)
  pno.null.I = numeric()
  for (i in 1:100){
    pno.null.I[i] = pno.null(sp1,sp2, env.var)
  }
  pno.list = list(pno.empirical, pno.null)
  names(pno.list) = c('pno.empirical','pno.null')
  return(pno.list)
}

#-------------------------------------------------------------------------------
# Run PNO
#-------------------------------------------------------------------------------
# THIS TAKES A VERY LONG TIME TO RUN!

pno.lf.sf = list()
for(i in 1:15){
  pno.lf.sf[[i]] = run.pno('swd.lf.all','swd.sf.all',i)
}

pno.lf.ind = list()
for(i in 1:15){
  pno.lf.ind[[i]] = run.pno('swd.lf.all','swd.ind.all',i)
}

pno.sf.ind = list()
for(i in 1:15){
  pno.sf.ind[[i]] = run.pno('swd.sf.all','swd.ind.all',i)
}

names(pno.lf.sf) = names(env.stack)
names(pno.lf.ind) = names(env.stack)
names(pno.sf.ind) = names(env.stack)

#-------------------------------------------------------------------------------
# Plotting PNO
#-------------------------------------------------------------------------------


plot(pno.lf[,2]~pno.lf[,1], type = 'l', lwd = 2)
lines(pno.lf[,3]~pno.lf[,1], type = 'l', lwd = 2, lty = 3)

sum(abs(pno.lf[,2]-pno.lf[,3]))/2

head(pno.lf)
test.lf = mod.run('swd.lf.all')
test.sf = mod.run('swd.sf.all')

pno(env.stack[[1]],test.lf)
